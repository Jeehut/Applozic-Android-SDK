package com.applozic.mobicommons.people.channel;

import android.text.TextUtils;

import com.applozic.mobicommons.json.JsonMarker;
import com.applozic.mobicommons.people.contact.Contact;
import com.google.gson.annotations.Expose;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;

/**
 * A <i>channel</i> is the medium for multiple users to send and receive messages to and from each other. It facilitates a <i>group conversation</i>.
 *
 * <p>Channels are identified by their {@link #key} or {@link #clientGroupId}. The former is generated by <i>applozic</i>, latter can be set by you.</p>
 *
 * <p>Channels can also be called <i>groups</i>.</p>
 *
 * <p>Check out {@link GroupType} before you start.</p>
 *
 * <p>To send a message to a channel:</p>
 * <ul>
 *     <li>Create a new channel with the required users. Refer to <code>createChannelWithResponse(ChannelInfo channelInfo)</code> in <code>com.applozic.mobicomkit.channel.service.ChannelService</code>.</li>
 *     <li>Alternatively, you can add your user to an existing channel (if allowed, see {@link GroupType}). Refer to <code>addMemberToChannelProcessWithResponse(Integer channelKey, String userId)</code> in <code>com.applozic.mobicomkit.channel.service.ChannelService</code></li>
 *     <li>Note the {@link #key} or {@link #clientGroupId}.</li>
 *     <li>Send the message using the <code>com.applozic.mobicomkit.api.conversation.MessageBuilder</code> class.</li>
 * </ul>
 */
public class Channel extends JsonMarker {

    private Map<String, String> metadata = new HashMap<>();
    private Integer key;
    private Integer parentKey;
    private String parentClientGroupId;
    private String clientGroupId;
    private int subGroupCount;
    private String name;
    private String adminKey;
    private Short type;
    private int unreadCount;
    private int userCount;
    private String imageUrl;
    @Expose
    private String localImageUri;
    private Conversation conversationPxy;
    private List<Contact> contacts = new ArrayList<Contact>();
    private Long notificationAfterTime;
    private Long deletedAtTime;
    private int kmStatus;
    public static final String AL_CATEGORY = "AL_CATEGORY";
    public static final String CONVERSATION_STATUS = "CONVERSATION_STATUS";
    public static final String CONVERSATION_ASSIGNEE = "CONVERSATION_ASSIGNEE";
    public static final int CLOSED_CONVERSATIONS = 3;
    public static final int ASSIGNED_CONVERSATIONS = 1;
    public static final int ALL_CONVERSATIONS = 2;
    public static final String AL_BLOCK = "AL_BLOCK";

    public Channel() { }

    public Channel(Integer key, String name, String adminKey, Short type, int unreadCount, String imageUrl) {
        this.key = key;
        this.name = name;
        this.adminKey = adminKey;
        this.type = type;
        this.imageUrl = imageUrl == null ? "" : imageUrl;
        this.unreadCount = unreadCount;
    }

    public Channel(Integer key) {
        this.key = key;
    }

    public Channel(Integer key, String name) {
        this.key = key;
        this.name = name;
    }

    /**
     * Channel id. Generated by <i>applozic</i>.
     */
    public Integer getKey() {
        return key;
    }

    /**
     * @see #getKey()
     */
    public void setKey(Integer key) {
        this.key = key;
    }

    /**
     * Channel id. This can be set by you. See <code>ChannelInfo#setClientGroupId(String clientGroupId)</code>>.
     */
    public String getClientGroupId() {
        return clientGroupId;
    }

    /**
     * @see #getClientGroupId()
     */
    public void setClientGroupId(String clientGroupId) {
        this.clientGroupId = clientGroupId;
    }

    /**
     * The display name for your <i>channel</i>.
     */
    public String getName() {
        return name;
    }

    /**
     * @see #getName()
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * User-id (or user-ids separated by commas) of channel {@link ChannelUserMapper.UserRole admin/s}.
     */
    public String getAdminKey() {
        return adminKey;
    }

    /**
     * @see #getAdminKey()
     */
    public void setAdminKey(String adminKey) {
        this.adminKey = adminKey;
    }

    /**
     * @see GroupType
     */
    public Short getType() {
        return type;
    }

    /**
     * @see GroupType
     */
    public void setType(Short type) {
        this.type = type;
    }

    /**
     * Number of users in the channel.
     *
     * <p>{@link GroupType#OPEN} groups will return an <i>invalid</i> value. They do not store member count.</p>
     */
    public int getUserCount() {
        return userCount;
    }

    /**
     * @see #getUserCount()
     */
    public void setUserCount(int userCount) {
        this.userCount = userCount;
    }

    /**
     * The number of unread messages for this channel.
     */
    public int getUnreadCount() {
        return unreadCount;
    }

    /**
     * @see #getUnreadCount()
     */
    public void setUnreadCount(int unreadCount) {
        this.unreadCount = unreadCount;
    }

    /**
     * Gets the remote URL to the display picture for the <i>channel</i>.
     */
    public String getImageUrl() {
        return imageUrl;
    }

    /**
     * @see #getImageUrl()
     */
    public void setImageUrl(String imageUrl) {
        this.imageUrl = imageUrl;
    }

    /**
     * Gets the local URL to the display picture for the <i>channel</i>.
     */
    public String getLocalImageUri() {
        return localImageUri;
    }

    /**
     * @see #getLocalImageUri()
     */
    public void setLocalImageUri(String localImageUri) {
        this.localImageUri = localImageUri;
    }

    /**
     * Returns true for <i>broadcast</i> channels. See {@link GroupType}.
     */
    public boolean isBroadcastMessage() {
        return type.equals(GroupType.BROADCAST.getValue()) || type.equals(GroupType.BROADCAST_ONE_BY_ONE.getValue());
    }

    public Long getDeletedAtTime() {
        return deletedAtTime;
    }

    public void setDeletedAtTime(Long deletedAtTime) {
        this.deletedAtTime = deletedAtTime;
    }

    /**
     * Is this channel muted.
     */
    public boolean isNotificationMuted() {
        Date date = Calendar.getInstance(TimeZone.getTimeZone("UTC")).getTime();
        return (((getNotificationAfterTime() != null) && (getNotificationAfterTime() - date.getTime() > 0))
                || ((getNotificationAfterTime() != null && getNotificationAfterTime() == 0 && isGroupDefaultMuted())));
    }

    /**
     * For a muted channel (<code>ChannelService#muteNotifications(MuteNotificationRequest)</code>, returns the timestamp in milliseconds after
     * which notifications will resume. Otherwise 0.
     */
    public Long getNotificationAfterTime() {
        return notificationAfterTime;
    }

    /**
     * @see #getNotificationAfterTime()
     */
    public void setNotificationAfterTime(Long notificationAfterTime) {
        this.notificationAfterTime = notificationAfterTime;
    }

    public boolean isDeleted() {
        return (deletedAtTime != null && deletedAtTime > 0);
    }

    /**
     * Custom key-value data for the channel.
     *
     * <p>Example: You can use it to store the channel description.</p>
     * <code>
     *     {
     *         "description" : "Official group for the Bag-packers Worldwide."
     *     }
     * </code>
     *
     * <p><i>Note</i>: Channel metadata is also used internally. Do not over-write this field or it's existing values.</p>
     */
    public Map<String, String> getMetadata() {
        return metadata;
    }

    /**
     * @see #getMetadata()
     */
    public void setMetadata(Map<String, String> metadata) {
        this.metadata = metadata;
    }

    /**
     * @see GroupType
     */
    public boolean isOpenGroup() {
        return GroupType.OPEN.getValue().equals(type);
    }

    /**
     * Channel type. Different types have different properties.
     */
    public enum GroupType {
        /**
         * Any group member can add/remove members in this group.
         * Anyone can join a public group.
         */
        PUBLIC(2),
        /**
         * Only group admins can add/remove members in the group.
         */
        PRIVATE(1),
        /**
         * Does not have members. Users can subscribe to the MQTT topic and send, receive messages.
         * Push notifications are not supported.
         */
        OPEN(6),
        /**
         * Message sent in the broadcast group is received by the members of the group as a one-to-one conversation.
         * Only the sender has knowledge of the group.
         */
        BROADCAST(5),
        /**
         * Not required.
         */
        VIRTUAL(0),
        /**
         * Not required.
         */
        SELLER(3),
        /**
         * Not required.
         */
        SELF(4),
        /**
         * Not required.
         */
        GROUPOFTWO(7),
        /**
         * Not required.
         */
        CONTACT_GROUP(9),
        /**
         * Not required.
         */
        SUPPORT_GROUP(10),
        /**
         * Not required.
         */
        BROADCAST_ONE_BY_ONE(106);

        private Integer value;

        GroupType(Integer value) {
            this.value = value;
        }

        public Short getValue() {
            return value.shortValue();
        }
    }

    @Override
    public String toString() {
        return "Channel{" +
                "metadata=" + metadata +
                ", key=" + key +
                ", parentKey=" + parentKey +
                ", parentClientGroupId='" + parentClientGroupId + '\'' +
                ", clientGroupId='" + clientGroupId + '\'' +
                ", subGroupCount=" + subGroupCount +
                ", name='" + name + '\'' +
                ", adminKey='" + adminKey + '\'' +
                ", type=" + type +
                ", unreadCount=" + unreadCount +
                ", userCount=" + userCount +
                ", imageUrl='" + imageUrl + '\'' +
                ", localImageUri='" + localImageUri + '\'' +
                ", conversationPxy=" + conversationPxy +
                ", contacts=" + contacts +
                ", notificationAfterTime=" + notificationAfterTime +
                ", deletedAtTime=" + deletedAtTime +
                ", kmStatus=" + kmStatus +
                '}';
    }

    /**
     * Internal. You will not need this method.
     */
    public boolean isGroupDefaultMuted() {
        return (getMetadata() != null && getMetadata().get(ChannelMetadata.MUTE) != null
                && getMetadata().get(ChannelMetadata.MUTE).equalsIgnoreCase("true"));
    }

    /**
     * Do not use. Parent channels will be deprecated soon.
     */
    public Integer getParentKey() {
        return parentKey;
    }

    /**
     * Do not use. Parent channels will be deprecated soon.
     */
    public void setParentKey(Integer parentKey) {
        this.parentKey = parentKey;
    }

    /**
     * Do not use. Parent channels will be deprecated soon.
     */
    public String getParentClientGroupId() {
        return parentClientGroupId;
    }

    /**
     * Do not use. Parent channels will be deprecated soon.
     */
    public void setParentClientGroupId(String parentClientGroupId) {
        this.parentClientGroupId = parentClientGroupId;
    }

    /**
     * Do not use. Parent channels will be deprecated soon.
     */
    public int getSubGroupCount() {
        return subGroupCount;
    }

    /**
     * Do not use. Parent channels will be deprecated soon.
     */
    public void setSubGroupCount(int subGroupCount) {
        this.subGroupCount = subGroupCount;
    }

    /**
     * Internal Method. You will not need it.
     *
     * Checks for metadata value with key {@link ChannelMetadata#ADMIN_ONLY_MESSAGE_CLIENT_SUPPORT_CHANNEL_METADATA_KEY}
     *
     * <p>This boolean metadata value has been added to let a request (for support for letting only admins send messages
     * to a group) be sent with the group create/update api.
     * The client UI can then implement the required functionality from its side accordingly.
     * The applozic UI Kit implements this functionality by replacing the message send view
     * with an appropriate message.</p>
     *
     * @return returns true if it's present and with value true and false otherwise.
     */
    public boolean hasAdminOnlyMessageClientSupportRequest() {
        final String TRUE_STRING = "true";
        if(metadata == null) {
            return false;
        }
        return metadata.containsKey(ChannelMetadata.ADMIN_ONLY_MESSAGE_CLIENT_SUPPORT_CHANNEL_METADATA_KEY) && TRUE_STRING.equalsIgnoreCase(metadata.get(ChannelMetadata.ADMIN_ONLY_MESSAGE_CLIENT_SUPPORT_CHANNEL_METADATA_KEY));
    }

    /**
     * Internal. You will not need this method.
     */
    public boolean isPartOfCategory(String category) {

        return (this.metadata != null && this.metadata.containsKey(AL_CATEGORY)
                && this.metadata.get(AL_CATEGORY).equals(category));

    }

    /**
     * Internal. You will not need this method.
     */
    public boolean isContextBasedChat() {
        return (this.metadata != null && "true".equals(this.metadata.get(ChannelMetadata.AL_CONTEXT_BASED_CHAT)));
    }

    /**
     * Do not use. This method will be deprecated soon.
     */
    public int getKmStatus() {
        return kmStatus;
    }

    /**
     * Internal. You will not need this method.
     */
    public void setKmStatus(int kmStatus) {
        this.kmStatus = kmStatus;
    }

    /**
     * Do not use. This method will be deprecated soon.
     */
    public int generateKmStatus(String loggedInUserId) {
        if (getMetadata() == null) {
            return ASSIGNED_CONVERSATIONS;
        }

        if (getMetadata().containsKey(CONVERSATION_STATUS) && ("2".equals(getMetadata().get(CONVERSATION_STATUS)) || "3".equals(getMetadata().get(CONVERSATION_STATUS)))) {
            return CLOSED_CONVERSATIONS;
        }

        if (getMetadata().containsKey(CONVERSATION_ASSIGNEE) && !TextUtils.isEmpty(getMetadata().get(CONVERSATION_ASSIGNEE))) {
            if (!TextUtils.isEmpty(loggedInUserId) && loggedInUserId.equals(getMetadata().get(CONVERSATION_ASSIGNEE))) {
                return ASSIGNED_CONVERSATIONS;
            }
            return ALL_CONVERSATIONS;
        }
        return ASSIGNED_CONVERSATIONS;
    }

    /**
     * @deprecated This method is no longer used and will be removed soon.
     */
    @Deprecated
    public boolean blockNotification(Short loggedInUserRole) {
        return isNotificationMuted() || (GroupType.SUPPORT_GROUP.getValue().equals(getType())
                && loggedInUserRole != 3
                && (getKmStatus() == ALL_CONVERSATIONS || getKmStatus() == CLOSED_CONVERSATIONS));
    }

    /**
     * @deprecated This method is no longer used and will be removed soon.
     */
    @Deprecated
    public int getConversationStatus() {
        return (GroupType.SUPPORT_GROUP.getValue().equals(getType()) && getMetadata() != null && !TextUtils.isEmpty(getMetadata().get(CONVERSATION_STATUS))) ? Integer.parseInt(getMetadata().get(CONVERSATION_STATUS)) : -1;
    }

    /**
     * @deprecated This method is no longer used and will be removed soon.
     */
    @Deprecated
    public String getConversationAssignee() {
        return (GroupType.SUPPORT_GROUP.getValue().equals(getType()) && getMetadata() != null && !TextUtils.isEmpty(getMetadata().get(CONVERSATION_ASSIGNEE))) ? getMetadata().get(CONVERSATION_ASSIGNEE) : null;
    }

    /**
     * @deprecated This method is not used and will be removed soon.
     */
    @Deprecated
    public List<Contact> getContacts() {
        return contacts;
    }

    /**
     * @deprecated This method is not used and will be removed soon.
     */
    @Deprecated
    public void setContacts(List<Contact> contacts) {
        this.contacts = contacts;
    }

    /**
     * @deprecated This method is not used and will be removed soon.
     */
    @Deprecated
    public Conversation getConversationPxy() {
        return conversationPxy;
    }

    /**
     * @deprecated This method is not used and will be removed soon.
     */
    @Deprecated
    public void setConversationPxy(Conversation conversationPxy) {
        this.conversationPxy = conversationPxy;
    }

    /**
     * Internal. Do not use.
     */
    public enum GroupMetaDataType {

        TITLE("title"),
        PRICE("price"),
        LINK("link");

        private String value;

        GroupMetaDataType(String value) {
            this.value = value;
        }

        public String getValue() {
            return value;
        }
    }

    /**
     * @deprecated Functionality disabled.
     */
    @Deprecated
    public static class AlConversationStatus {
        public static final String RESOLVED_STATUS = "Resolved";
        public static final String SPAM_STATUS = "Spam/Irrelevant";
        public static final String OPEN_STATUS = "Open";
        public static final String CLOSED = "2";
        public static final String RESOLVED = "3";
    }
}
